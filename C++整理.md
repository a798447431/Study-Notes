```c++
//快速排序  二叉排序树思想
void quick_sort(int *num, int l, int r) {
    if (r <= l) return ;
    int x = l, y = r, z = num[l];
    while (x < y) {
        while (x < y && num[y] >= z) y--;
        if (x < y) num[x++] = num[y];
        while (x < y && num[x] <= z) x++;
        if (x < y) num[y--] = num[x];
    }
    num[x] = z;
    quicksort(num, l, x - 1);
    quicksort(num, x + 1, r);
    return ;
}
```

```c++
//选择排序
void select_sort(int *num, int n) {
    for (int i = 0; i < n - 1; i++) {
        int ind = i;
        for (int j = i + 1; j < n; j++) {
            if (num[ind] > num[j]) ind = j;
        }
        swap(num[ind], num[i]);
    }
    return ;
}
```

```c++
//插入排序
void insert_sort(int *num, int n) {
    for (int i = 1; i < n; i++) {
        for (int j = i; j > 0; j--) {
            if (num[j] >= num[j - 1]) continue;
            swap(num[j], num[j - 1]);
        }
    }
    return ;
} 
```

```c++
//冒泡排序 链表
void bubble_sort(int *num, int n) {
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < n - i; j++) {
            if (num[j] <= num[j + 1]) continue;
            swap(num[j], num[j + 1]);
        }
    }
    return ;
}
```

```c++

```





## 1. C/C++各自的特点

- C语言是一种结构化语言，面向过程。基于算法和数据结构，所考虑的是如何通过一个过程或者函数从输入得到输出。

- C++是面向对象，基于类、对象和继承，所考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题，通过获取对象的状态信息得到输出或实现过程控制。

## 面向对象的三个基本特征

- **封装**：将数据和函数等集合在一个单元中（即类）。被封装的类通常称为抽象数据类型。封装的意义在于保护或者防止代码（数据）被我们无意中破坏。
- **继承**：继承主要实现重用代码，节省开发时间。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 
- **多态**：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向派生类的基类指针，来调用实现派生类中的方法。有编译时多态和运行时多态。

## 变量的声明和定义的区别

为变量分配地址和存储空间的称为**定义**，不分配地址的称为**声明**。一个变量可以在多个地方声明，但只能在一个地方定义。加入**extern**修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

**！！说明**

很多时候，一个变量只是声明，不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。

## 2. extern关键字的作用

​	extern置于变量或函数前，用于标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。它只有两个作用：

- 当它与"C"一起连用的时候，如：

    `extern "C" void fun(int a, int b);`

    则告诉编译器在编译fun()这个函数时按照C的规矩去编译，而不是C++的（这与C++的重载有关，C++语言支持函数重载，C语言不支持函数重载，函数被C++编译器编译后在库中的名字与C语言的不同）。

- 当extern不与"C"一起连用的时候，如：

    `extern int g_int;`

    它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其它模块中使用。**记住它是一个声明不是定义**！也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可，在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

## 3. static关键字的作用

- **修饰局部变量**

    static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）。

- **修饰全局变量**

    全局变量本来就存储静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性，被static修饰的全局变量只能被包含该定义的文件访问（即改变了作用域）。
  
- **修饰函数**

    static修饰函数使得函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。
    
- **修饰成员变量**

    用static修饰类的数据成员使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象，所有的对象都只维持同一个实例。因此，static成员必须在类外进行初始化（初始化格式：int base::var = 10;），而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。

```c++
class Cextern
{
	public:
	int a;
	static int b;
	int getA()const
	{
    	return a;
	};
	int getB()const{return b;};
	void addB()
	{
		b += b;
	}
	void addA()
	{
    	a += a;
	}
};
int Cextern::b = 10;
```

- **修饰成员函数**

    无法访问属于类对象的非静态数据成员和非静态的成员函数。与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此不具有this指针，从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。

**不可以同时用const和static修饰成员函数**

## 4. volatile的作用

- 修饰符 **volatile** 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。

## 5. const的作用

**使用const关键字修饰的变量，一定要对变量进行初始化**

- 定义变量为只读变量，不可修改。

    `const int a = 100; //a++`会产生错误`
    
- 修饰函数的参数和返回值，便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。

  `void fun(const int i){...} //i`不允许修改`
  
- const成员函数（只需要在成员函数参数列表后加上关键字const，如

    `char get() const;`
    
    可以访问const成员变量和非const成员变量，但不能修改任何变量。在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const成员函数。
    
- const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。

    `即对于class A，有const A a；`

    那么a只能访问A的const成员函数。而对于：A b；b可以访问任何成员函数。

- 可以节省空间，避免不必要的内存分配。例如

    ```c++
    #define PI 3.14159    //常量宏 
    const double Pi=3.14159;    //此时并未将Pi放入RAM中
    double i=Pi;    //此时为Pi分配内存，以后不再分配！ 
    double I=PI;    //编译期间进行宏替换，分配内存 
    double j=Pi;    //没有内存分配 
    double J=PI;    //再进行宏替换，又一次分配内存！ 
    ```

    const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干份拷贝。

- 提高效率

  编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
  

## const和#define的区别

const和#define都可以定义常量，但前者比后者由更多的优点：

- **const常量有类型，而宏定义常量没有类型。**编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且字符替换可能产生意料不到的错误（**边际效应**）
- 有些集成化的调试工具可以对const常量进行调试，但是不能对宏定义常量进行调试

区别：

1. 编译器处理方式不同

    - define宏是在预处理阶段展开

    - const常量是编译运行阶段使用

2. 类型和安全检查不同
   - define宏没有类型，不做任何类型检查，仅仅是展开
   - const常量有具体的类型，在编译阶段会执行类型检查
   
3. 存储方式不同
   - define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。
   - const常量会在内存中分配(可以是堆中也可以是栈中)。
   
4. const 可以节省空间，避免不必要的内存分配。
   
   const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而 #define定义的常量在内存中有若干个拷贝。
   
5. 提高了效率

    编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

## 类的默认成员函数

- ### **构造函数**

    **1.什么是构造函数**

    一个特殊的成员函数，名字与类名相同，创建类类型对象的时候，由编译器自动调用，在对象的生命周期内只且调用一次，以保证每个数据成员都有一个合适的初始值。

    **2.构造函数的特性**

    - 函数名和类名相同
    - 没有返回值
    - 有初始化列表（可以不用）
    - 新对象被创建，由编译器自动调用，且在对象的生命周期内仅调用一次
    - 构造函数可以重载，实参决定了调用哪个构造函数
    - 如果没有显示的调用时，编译器会提供一个默认的构造函数
    - 无参构造函数和带有缺省值的构造函数都认为是缺省构造函数，并且缺省构造函数只能有一个
    - 构造函数不能用const修饰（因为const修饰类的成员函数时，该函数不能修改成员变量，但是构造函数要修改类的成员变量，因此不可以用const修饰）

    **3.初始化列表**

    以冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。

    ```c++
    Date(int year, int month, int day)
    	:_year(year)
    	, _month(month)
    	, _day(day)
    {
    }
    ```

    **4.初始化顺序**

    - 数据成员在类中定义的顺序就是参数列表中的初始化顺序
    - 初始化列表仅用于初始化数据成员，并不指定这些数据成员的初始化顺序
    - 每个成员在初始化列表中只能出现一次
    - 尽量避免使用成员初始化成员，成员初始化顺序最好和成员的定义顺序保持一致

    > **类中包含以下成员必须要放在初始化列表中初始化：**
    >
    > ​    (1) 引用数据类型
    >
    > ​    (2) const数据类型
    >
    > ​    (3) 类类型成员（该类没有缺省的构造函数）

    **5.默认构造函数**

    默认构造函数使用与成员变量初始化相同的规则初始化成员，对于内置类型和复合类型的成员，如组、指针，只对定义在全局定义作用于的对象初始化，对于局部作用域的内置和复合类型不作初始化。

    **6.构造函数的作用**

    - 构建对象
    - 初始化对象
    - 类型转换

    **7.explcit**

    用explicit修饰构造函数，抑制由构造函数定义的隐式转换，explicit关键字类内部的构建声明上，在类的定义体外部的定义上不再重复。

- ### **拷贝构造函数**

    **1.概念**

    只有单个形参，而且该形参是对本类类型对象的引用（常用const修饰），这样的构造函数称为拷贝构造函数。拷贝构造函数是特殊的构造函数，创建对象时使用已存在的同类对象来进行初始化，由编译器自动调用。

    **2.特征**

    - 它是构造函数的重载
    - 它的参数必须使用同类型对象的引用传递，使用传参方式会引发无穷递归调用
    - 如果没有显示定义，系统会自动合成一个默认的拷贝构造函数。默认的拷贝构造函数会依次拷贝类的数据成员完成初始化。

    **3.使用场景**

    - 使用已存在的对象创建新的对象

    ```c++
    CDate d1(1990, 1, 1);
    CDate d2(d1);
    ```

    - 传值方式作为函数的参数

    ```c++
    void FunTest(const CDate date)
    {}
    ```

    - 传值方式作为函数的返回值

    ```c++
    CDate FunTest()
    {
    	CDate date;
    	return date;
    }
    ```

- ### **析构函数**

    **1.概念**

    与构造函数功能相反，在对象被销毁时，由编译器自动调用，完成类的一些资源清理和汕尾工作。

    **2.特性**

    - 析构函数在类名（即构造函数名）加上字符~
    - 析构函数无参数无返回值，所以不能重载
    - 一个类有且只有一个析构函数。若未显示定义，系统会自动生成缺省的析构函数
    - 对象生命周期结束时，C++编译系统自动调用析构函数
    - 因为函数压栈的关系，所以先构造的后析构，后构造的先析构。如果有全局对象或者静态局部对象，则它们在main函数结束或者调用exit函数时才被析构
    - 注意析构函数体内并不是删除对象，而是做一些清理工作，比如关闭打开的文件，释放开辟的动态内存等

- ### **赋值操作符重载**

    **1.概念**

    对于类类型的对象我们需要对'='重载，已完成类类型对象之间的赋值。

    **2.static成员**

    声明为static的类成员(成员数据或成员函数）称为类的静态成员。

    特性：

    - 静态成员为所有类对象所共享，不属于某个具体的实例

    - 类静态成员即可用类名::静态成员或者对象.静态成员来访问
    - 类静态成员变量必须在类外定义，定义时不添加static关键字
    - 类的静态成员函数没有默认的this指针，因此在它里面不能使用任何非静态成员

    - 静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数

    **！！注意**

    **（1）静态成员函数不可以调用非静态成员函数**

    **（2）非静态成员函数可以调用静态的成员函数**

    **3.const修饰类成员**

    使用场景：

    - const修饰形参，一般和引用同时使用
    - const修饰返回值
    - const修饰类数据成员，必须在构造函数的初始化列表中初始化
    - const修饰类成员函数，实际修饰隐含的this，表示在类中不可以对类的任何成员进行修改
    - 在const修饰的成员函数中要对类的某个数据成员进行修改，该数据成员定义声明是必须加mutable关键字。

    **！！说明**

    **const对象不可以调用非const成员函数**

    **非const成员函数可以调用const成员函数**

- ### **取地址操作符重载**

    取址操作符重载函数返回值为该类型的指针，无参数。

- ### **const修饰的取地址操作符重载**

  ```c++
  const String* operator&() const
  {
  	return this;
  }
  ```
  
  函数后边的const表明在函数体中不能改变对象的成员，当然可以改变mutable变量。函数的返回值是指向常对象的指针。

## **头文件中的ifndef/define/endif的作用**

​    这是C++预编译头文件保护符，保证即使文件被多次包含，头文件也只定义一次。

## #include<file.h>与#include "file.h"的区别

​    前者是从标准库路径寻找和引用file.h，而后者是从当前工作路径搜索并引用file.h。

## 内联函数、宏定义和普通函数的区别

- 内联函数要做<font color=blue>参数类型检查</font>，这是内联函数跟宏相比的优势
- 宏定义是在<font color=blue>预编译</font>的时候把所有的宏名用宏体来替换，简单的说就是字符串替换，内联函数则是在<font color=blue>编译</font>的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样就可以省去函数调用的压栈出栈的开销，提高效率。
- 内联函数是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。对于短小简单的代码来说，内联函数可以带来一定的效率提升，而且和C的宏函数相比，内联函数更安全可靠。可是这个是以**增加空间消耗**为代价的。

## <font color=red>宏定义只是简单的符号替换</font>

```c++
#include <stdio.h>  
#define S(a,b) a*b  
  
int main(void)  
{  
	int n = 3;  
	int m = 5;  
	printf("%d",S(n+m,m+n));  
  
	return 0;  
} 
```

> 3 + 5 * 5 * 3 = 31

```c++
#include <stdio.h>] 
#define N  2 
#define M  N+1 
#define NUM  (M+1)*M/2 

int main() 
{ 
	printf("%d",NUM);  
} 
```

> (2 + 1 + 1) * 2 + 1 / 2 = 8

## new，delete与malloc，free的区别与联系

<font color=red>malloc/free是C++标准库函数，new/delete是C++运算符。</font>它们都可以用于动态申请和释放内存。

对于内置类型数据而言，二者没有多大区别。malloc申请内存的时候要制定分配内存的字节数，而且不会做初始化；new申请的时候有默认的初始化，同时可以指定初始化。

对于类类型的对象而言，用malloc/free无法满足要求的。对象在创建的时候要自动执行构造函数，消亡之前要调用析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制之内，不能把执行构造函数和析构函数的任务强加给它，因此，C++还需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。

## 指针与引用的区别

- **指针是变量**，这个变量存放的是所指内容的地址。**引用是别名**，与所引用变量占用同一内存空间。
- **指针可以是空**，不必在定义的时候初始化，初始化后可以改变；**引用不能为空**，必须在定义的时候初始化，而且初始化之后就不能再改变。
- "sizeof(引用)" = 指向变量的大小；"sizeof(指针)" = 指针本身的大小。
- 指针可以有多级，而引用只能是一级。
- 都可以作为函数参数。引用的主要作用是传递函数的参数和返回值。

## C++线程锁

线程之间的锁有：<font color=red>互斥锁、条件锁、自旋锁、读写锁、递归锁</font>。一般而言，锁的功能越强大，性能就会越低。

**1.互斥锁**

**互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量**。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。

在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。

```c++
头文件：<pthread.h>

类型：pthread_mutex_t，

函数：
pthread_mutex_init(pthread_mutex_t * mutex, const phtread_mutexattr_t * mutexattr);//动态方式创建锁，相当于new动态创建一个对象

pthread_mutex_destory(pthread_mutex_t *mutex)//释放互斥锁，相当于delete

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//以静态方式创建锁

pthread_mutex_lock(pthread_mutex_t *mutex)//以阻塞方式运行的。如果之前mutex被加锁了，那么程序会阻塞在这里。

pthread_mutex_unlock(pthread_mutex_t *mutex)

int pthread_mutex_trylock(pthread_mutex_t * mutex);//会尝试对mutex加锁。如果mutex之前已经被锁定，返回非0,；如果mutex没有被锁定，则函数返回并锁定mutex
//该函数是以非阻塞方式运行了。也就是说如果mutex之前已经被锁定，函数会返回非0，程序继续往下执行。
```

**2.条件锁**

条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。这个过程中就使用到了条件变量pthread_cond_t。

```c++
头文件：<pthread.h>

类型：pthread_cond_t

函数：
//对条件变量进行动态初始化，相当于new创建对象
pthread_cond_init(pthread_cond_t * condtion, const phtread_condattr_t * condattr);
//释放动态申请的条件变量，相当于delete释放对象
pthread_cond_destory(pthread_cond_t * condition);
//静态初始化条件变量
pthread_cond_t condition = PTHREAD_COND_INITIALIZER;

pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex);
//该函数以阻塞方式执行。如果某个线程中的程序执行了该函数，那么这个线程就会以阻塞方式等待，直到收到pthread_cond_signal或者pthread_cond_broadcast函数发来的信号而被唤醒。
```

**！！注意：**pthread_cond_wait()函数的语义相当于：首先解锁互斥锁，然后以阻塞方式等待条件变量的信号，收到信号后又会对互斥锁加锁。

为了防止“虚假唤醒”，该函数一般放在while循环体中。例如

```c++
pthread_mutex_lock(mutex);//加互斥锁
while(条件不成立)//当前线程中条件变量不成立
{
	pthread_cond_wait(cond, mutex);//解锁，其他线程使条件成立发送信号，加锁。
}
...//对进程之间的共享资源进行操作
pthread_mutex_unlock(mutex);//释放互斥锁
```
```c++
pthread_cond_signal(pthread_cond_t * cond);//在另外一个线程中改变线程，条件满足发送信号。唤醒一个等待的线程（可能有多个线程处于阻塞状态），唤醒哪个线程由具体的线程调度策略决定

pthread_cond_broadcast(pthread_cond_t * cond);//以广播形式唤醒所有因为该条件变量而阻塞的所有线程，唤醒哪个线程由具体的线程调度策略决定

pthread_cond_timedwait(pthread_cond_t * cond, pthread_mutex_t * mutex, struct timespec * time);//以阻塞方式等待，如果时间time到了条件还没有满足还是会结束
```

**3.自旋锁**

前面的两种锁是比较常见的锁，也比较容易理解。下面通过比较互斥锁和自旋锁原理的不同，这对于真正理解自旋锁有很大帮助。

假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。

首先我们说明互斥锁的工作原理，互斥锁是是一种**sleep-waiting**的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。

而自旋锁就不同了，自旋锁是一种**busy-waiting**的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的。

```c++
头文件：<linux\spinlock.h>

自旋锁的类型：spinlock_t

相关函数：
初始化：spin_lock_init(spinlock_t *x);

spin_lock(x);//只有在获得锁的情况下才返回，否则一直“自旋”

spin_is_locked(x)//该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，返回真，否则返回假。
```

**！！注意：**自旋锁适合于短时间的的轻量级的加锁机制。

**4.读写锁**

说到读写锁我们可以借助于“读者-写者”问题进行理解。首先我们简单说下“读者-写者”问题。

计算机中某些数据被多个进程共享，对数据的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。

## 智能指针

当类中有指针成员时，一般有两种方式来管理指针成员：

- 一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝
- 另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享。

智能指针的一种通用实现技术是使用引用计数。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。

每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

## 栈和堆的区别

- 管理方式不同：栈是编译器自动管理的，堆需手动释放
- 空间大小不同：在32位OS下，堆内存可达到4GB的的空间，而栈就小得可怜。(VC6中，栈默认大小是1M，当然，你可以修改它)
- 能否产生碎片不同：对于栈来说，进栈/出栈都有着严格的顺序(先进后出)，不会产生碎片；而堆频繁的new/delete，会造成内存空间的不连续，容易产生碎片。
- 生长方向不同：栈向下生长，以降序分配内存地址；堆向上生长，以升序分配内在地址。
- 分配方式不同：堆动态分配，无静态分配；栈分为静态分配和动态分配。
- 分配效率不同：栈是系统提供的数据结构，计算机会在底层对栈提供支持，进栈/出栈都有专门的指令，这就决定了栈的效率比较高。堆则不然，它由C/C++函数库提供，机制复杂，**堆的效率要比栈低得多**。

## 调用函数时要进行参数压栈，一般情况下顺序是<font color=red>从最右边参数往左</font>压栈

## 字符数组与字符串的比较：最明显的区别是字符串会在末尾自动添加空字符

## C++函数中值的传递方式

- 值传递
- 指针传递
- 引用传递

## 全局对象的构造函数会在main函数之前执行，可以用_onexit注册一个函数，它会在main函数之后执行

## 进程和线程的区别

- 进程是程序的一次执行，线程是进程中的执行单元
- 进程间是独立的，这表现在内存空间、上下文环境上，线程运行在进程中
- 一般来讲，进程无法突破进程边界存取其它进程内的存储空间；而同一进程所产生的线程共享内存空间
- 同一进程中的两段代码不能同时执行，除非引入多线程

## 重载和重写的区别

- 从定义上来说：
    - 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
    - 重写：是指子类重新定义父类虚函数的方法。
- 从实现原理上来说：
    - 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数。
    - 重写：当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类虚函数的地址无法给出）。

**！补充**

- "隐藏"是指派生类的函数屏蔽了与其同名的基类函数。规则如下：
    - 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。
    - 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时，基类的函数被隐藏。

## class、struct、union的区别

- class（类）
    - 类用来定义对象
    - 默认情况下成员私有（private）
    - 成员不一定按声明顺序存储
- struct（结构体）
    - 结构体用来定义过程或者结构（及一堆属性的集合）
    - 默认情况下成员公有（public）
    - 成员按声明顺序在内存中存储，但不一定是连续的
- union（联合体/共用体）
    - 联合体用于定义一些特殊结构
    - 所有成员共用一块内存，内存的大小与成员中长度的最大的决定
    - 成员变量按声明顺序在内存中存储，并且内存是连续的

## C++的多态性

多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数 。C++多态性主要是通过虚函数实现的，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）

多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。

在绝大多数情况下，程序的功能是在编译的时候就确定下来的，我们称之为静态特性。反之，如果程序的功能是在运行时刻才能确定下来的，则称之为动态特性。C++中，虚函数，抽象基类，动态绑定和多态构成了出色的动态特性。

最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。

**！！a、编译时多态性：通过重载函数实现**

**！！b、运行时多态性：通过虚函数实现**

## 内存溢出，内存泄漏的原因

- 内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。原因可能如下：
    - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据
    - 代码中存在死循环或循环产生过多重复的对象实体
    - 递归调用太深，导致堆栈溢出等
    - 内存泄漏最终导致内存溢出
- 内存泄漏是指向系统申请分配内存进行使用（new），但是用完后不归还（delete），导致占用有效内存。常见的几种情况：
  
    - 在类的构造函数和析构函数中没有匹配的调用**new**和**delete**函数
    
        两种情况下会出现这种内存泄露：一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构 函数中没有释放内存或者没有正确的释放内存
    
    - 在释放对象数组时在**delete**中没有使用方括号
    
        方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值病调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。
    
    - 没有将基类的析构函数定义为虚函数
    
        当基类指针指向子类对象时，如果基类的析构函数不是**virtual**，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

## 指针常量和常量指针

```c++
int b = 500;
const int *a = &b;
int const *a = &b;
int *const a = &b;
const int* const a = &b;
```



